package em.twitterido.aw;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.StatusLine;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.Configuration;
import android.os.Bundle;
import android.os.Vibrator;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;
import dk.itu.yili.nfc.parser.NFCIntentParser;

/**
 * 
 * 
 * @author elenanazzi
 * 
 *         This is the basic structure of an application for twitterido At first
 *         this will cover the interface with the Genie Hub is a very simple way
 *         The main screen will have two buttons to start a new activity and to
 *         stop it and a text area that will be dedicated to the visualization
 *         of new activities.
 * 
 *         Here we have a GENERATOR of events in the GHService and here it is an
 *         example:
 * 
 *         Generator g = new GeneratorAdapter("em.activity.generator",
 *         "activity", "object", "user", "state", "timestamp");
 * 
 *         EventBuilder ebuilder = new EventBuilder(); String activity =
 *         "shopping"; String object = "object01"; String user = "user01";
 *         String status; long timestamp;
 * 
 *         This GENERATOR is activated by two INTENTs generated by the onClick
 *         of the two buttons: START_INTENT and STOP_INTENT from the
 *         BasicEmActivity class
 * 
 * 
 *         We also have a LISTENER for gh events
 * 
 *         Listener l = new Listener(new PatternBuilder().add( activity,
 *         PatternOperator.EQ, "shopping").getPattern()) {...}
 * 
 *         The LISTENER generates an INTENT onMessageReceived that is then
 *         catched by BasicEmActivity class and a textView is updated with the
 *         number of events available. Currently there is no filter for the
 *         OBJECT ID or USER ID.
 */
public class PersonalEMActivity extends Activity {

	private static final String TAG = "PersonalEM";

	public static final String ACTIVITY_INTENT = "em.twitterido.aw.BasicEMActivity.ACTIVITY";
	public static final String SHARE_INTENT = "em.twitterido.aw.BasicEMActivity.SHARE";
	public static final String GHEVENT_INTENT = "em.twitterido.aw.BasicEMActivity.GH_EVENT";
	// public static final String NFC_SHARE_INTENT =
	// "em.twitterido.aw.BasicEMActivity.NFC_SHARE";
	public static final String NFC_DISCOVERED_INTENT = "android.nfc.action.NDEF_DISCOVERED";

	private static final String uri = "http://idea.itu.dk:8080/";
	private static final String diaspora = "@idea.itu.dk:3000";
	private SharedPreferences preferences;
	private HttpClient client = new DefaultHttpClient();

	/* DEBUG testing elements */
	public TextView activityNotification;

	/* Gallery Handling */
	public View lastSelectedView = null;

	/* preferences and configuration */
	public static final String CONFIG_USER = "config_user"; // where the
															// preferences are
	public String user; // name of the current user 1. retrieved by preferences
						// or updated from the menu
	protected ArrayList<String> contact_names = new ArrayList<String>(); // names
																			// of
																			// the
																			// contacts
																			// of
																			// the
																			// user
																			// for
																			// an
																			// activity
	public int[] contacts; // ids of the contacts of a user for an activity
	public String activity; // TODO: define how to discern the activity: user
							// input, nfc recognition

	public String object; // I should get this information form the usb
							// accessory mode I can actually check on the value
							// of the channel... mm no
	public String content; // the accessory mode is sending the messages
							// defining the content + content is defined when an
							// offer is posted = url of the image just posted

	HashMap<String, Integer> notificationCounter = new HashMap<String, Integer>(); // this
																					// object
																					// should
																					// keep
																					// the
																					// temporary
																					// status
																					// of
																					// who
																					// is
																					// out
																					// and
																					// who
																					// is
																					// sharing

	BroadcastReceiver br = new BroadcastReceiver() {

		public void onReceive(Context context, Intent intent) {
			// TODO Auto-generated method stub
			Log.d(TAG, intent.getAction());

			if (intent.getAction().equals(PersonalEMActivity.GHEVENT_INTENT)) {
				Log.d(TAG, "GHEVENT_INTENT catched");
				updateInfo(intent);
			}

			if (intent.getAction().equals(ADKService.SENSOR_EVENT)) {
				Log
						.d(TAG,
								"ADKService SENSOR EVENT catched in Broadcast receiver");
				activityNotification.setText("Here we have a sensor intent!!");
				handleSensorEvent(intent);
			}

			// if
			// (intent.getAction().equals("android.nfc.action.TAG_DISCOVERED")){
			// Log.d(TAG, "NFC_DISCOVERED Receiver catched it");
			//				
			// String s = NFCIntentParser.parse(intent);
			// Log.d(TAG, "NFC string parsed"+s);
			//		
			// }
			// if
			// (intent.getAction().equals(PersonalEmActivity.NFC_SHARE_INTENT))
			// {
			// Log.d(TAG, "NFC_SHARE catched");
			// if (intent.getExtras() != null) {
			// shareSpark(intent.getExtras());
			// }
			//
			// }

		}

	};

	private String actor;

	public HttpClient getClient() {
		return client;
	}

	protected void handleSensorEvent(Intent intent) {
		// TODO Auto-generated method stub
		Bundle extras = intent.getExtras();
		if (extras == null) {
			return;
		}
		Log.d(TAG, "we have extras from SensorEvent");

		byte my = extras.getByte("my");
		// my = (byte) (my - 48);// test this first :) it might be not needed
		my = (byte) (my);
		Log.d(TAG, "SENDER ADDRESS IS: " + my);

		int type = extras.getInt("type");
		byte data[] = extras.getByteArray("data");

		activityNotification = (TextView) findViewById(R.id.activityNew);
		String msg = "";

		msg += "Actor: " + Byte.toString(my);
		msg += " just sent this message: ";
		// for (int i = 0; i < data.length; i++) {
		// msg += Byte.toString(data[i]) + " | ";
		// }
		msg += Byte.toString(data[0]) + " | ";
		if (my == 1) {
			// then I have a rollator (I know it is a stupid assumption but lets
			// try)
			ByteBuffer bb = ByteBuffer.wrap(data, 0, data.length); // I skip the
			// first
			// byte
			// because that is supposed to be the state of the button:
			// 1 => active (then converted to start),

			// 0 => inactive (then converted to stop)
			Toast.makeText(getApplicationContext(), "data length: "
					+ data.length + " ByteBuffer length: " + bb.capacity(),
					Toast.LENGTH_LONG);
			Log.d(TAG, "data length: " + data.length + " ByteBuffer length: "
					+ bb.capacity());

			bb.order(null);
			Short value = bb.getShort(1);
			// // int integer = (int)( // NOTE: type cast not necessary for int
			// // (0xff & data[0]) << 24 |
			// // (0xff & data[1]) << 16 |
			// // (0xff & data[2]) << 8 |
			// // (0xff & data[3]) << 0);
			// // Float flt = Float.intBitsToFloat(integer);
			msg += Short.toString(value);
		}

		msg += " of type " + type;
		activityNotification.setText(msg);

		// storing the data from the message received from the ADK
		// MY => object id
		// activity => shopping
		// content => start/stop/distance:

		// MessageGH m = new MessageGH();
		// m.setmActivity(activity);
		// m.setmObject(object);
		// m.setmContent(content);

		if (activity != "unknown") {
			Intent activityIntent = new Intent(ACTIVITY_INTENT);
			activityIntent.putExtra("user", user);
			activityIntent.putExtra("object", object);
			activityIntent.putExtra("activity", activity);
			activityIntent.putExtra("content", content);
			sendBroadcast(activityIntent);
			Log.d(TAG, "Created a New Activity " + activity);
		} else {
			Log.d(TAG, "Unknown activity with object " + object);
			activityNotification.setText("Unknown activity with object "
					+ object);
		}

	}

	/**
	 * 
	 * method called when a new GHEVENT_INTENT has been filtered
	 */
	protected void updateInfo(Intent intent) {
		Bundle extras = intent.getExtras();
		if (extras == null) {
			return;
		}
		Log.d(TAG, "we have extras from sensor");
		if (extras.getString("content") != null) {
			if (extras.getString("content").equals("start")) {
				notificationCounter.put(extras.getString("actor"), 1);
				notificationCounter.put("group", +1);
			} else if (extras.getString("state").equals("stop")
					&& notificationCounter.get("group") != 0) {
				notificationCounter.put(extras.getString("actor"), 0);
				notificationCounter.put("group", -1);
			}
		}
		activityNotification = (TextView) findViewById(R.id.activityNew);
		activityNotification.setText(notificationCounter + " New activities!");

		// vibrate to signal that new events are available
		Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);

		// // 1. Vibrate for 1000 milliseconds
		// long milliseconds = 1000;
		// v.vibrate(milliseconds);

		// 2. Vibrate in a Pattern with 500ms on, 500ms off for 5 times
		long[] pattern = { 500, 300, 500, 300, 500, 300 };
		v.vibrate(pattern, -1);

	}

	/* *
	 * method called when a NFC_SHARE_INTENT has been filtered or later when a
	 * picture will be shared! :)
	 */
	protected void shareSpark(Bundle extras) {
		// TODO Auto-generated method stub

		this.activityNotification.setText(content);

		/*
		 * This should be modified when the NFC parsing is ready and we should
		 * have an UPDATE to the genie hub
		 */
		Intent shareIntent = new Intent(SHARE_INTENT);
		shareIntent.putExtra("actor", actor);
		shareIntent.putExtra("activity", activity);
		shareIntent.putExtra("content", content);
		sendBroadcast(shareIntent);

	}

	/** Called when the activity is first created. */
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);

		initializeUI();

		/**
		 * 
		 * Set up NFC intent filter
		 * 
		 */
		Intent intent = getIntent();

		if (intent.getAction().equals("android.nfc.action.NDEF_DISCOVERED")) {
			Log.d(TAG, "NFC_DISCOVERED Receiver catched it oncreate");

			String s = NFCIntentParser.parse(intent);
			Log.d(TAG, "NFC string parsed" + s);
			activityNotification.setText("NFC string: " + s);

		}

		/**
		 * start the Accessory Service we need to send all the intent that
		 * activates this activity to the service in order for it to get the
		 * actual information that the accessory is transmitting
		 **/

		Intent megaIntent = getIntent(); // receive the intent from Mega board
		// broadcasted
		if (megaIntent.getAction().equals(
				"android.hardware.usb.action.USB_ACCESSORY_ATTACHED")) {
			Intent i = new Intent(this, ADKService.class);// generate new intent
			// for ADK service
			i.putExtras(megaIntent);
			startService(i);// start ADK service
			Log.d(TAG, "Started Service ADKService");
			activityNotification.setText("ADK connected");
		}

		/**
		 * TODO: fix this service to serve the GenieHub when included in the
		 * Client Application. Starting the Service that controls the GenieHub
		 * generators and listeners.
		 * 
		 */
		startService(new Intent(this, GHService.class));
		Log.d(TAG, "Started Service GHService");

		// adding the IntentFilters that will serve to the Broadcast receiver
		// to manage the intents within the application between the services and
		// the main activity
		// 

		IntentFilter flt = new IntentFilter();
		flt.addAction(PersonalEMActivity.GHEVENT_INTENT);
		flt.addAction(ADKService.SENSOR_EVENT);

		// flt.addDataScheme("http");
		// flt.addAction(BasicEmActivity.NFC_DISCOVERED_INTENT);
		// flt.addAction(BasicEmActivity.NFC_SHARE_INTENT);
		registerReceiver(br, flt);

	}

	private void initializeUI() {
		// TODO Auto-generated method stub
		this.activity = this.getString(R.string.activity);

		getUserfromPref();

		Log.d(TAG, "what is my user? " + user);

		getFriendsfromDiaspora();

		// Gallery g = (Gallery) findViewById(R.id.gallery);
		// g.setAdapter(new ImageAdapter(this));
		//
		// g.setOnItemClickListener(new OnItemClickListener() {
		// public void onItemClick(AdapterView parent, View v, int position,
		// long id) {
		// Toast.makeText(BasicEmActivity.this, "" + position,
		// Toast.LENGTH_SHORT).show();
		// }
		// });

		// YappsCircleGallery yappsGallery = (YappsCircleGallery)
		// findViewById(R.id.gallery);
		//		
		// yappsGallery.secondaryListener = new OnItemSelectedListener() {
		// public void onItemSelected(AdapterView<?> arg0, View arg1,
		// int arg2, long arg3) {
		// // TODO Auto-generated method stub
		// TextView t = (TextView) findViewById(R.id.captionText);
		// //String name = contact_names[(arg2 % contact_names.length)];
		// String name = contact_names.get((arg2 % contact_names.size()));
		// String started = "ikke";// notificationCounter.get(name) == 0 ?
		// "ikke ": "";
		// t.setText(contact_names.get((arg2 % contact_names.size())) + " er "
		// + started + activity);
		//
		// }
		//
		// public void onNothingSelected(AdapterView<?> arg0) {
		// // TODO Auto-generated method stub
		//
		// }
		// };
		activityNotification = (TextView) findViewById(R.id.activityNew);
		// activityNotification.setText("On Create, Status: "+
		// notificationCounter.values());

		ImageButton homeButton = (ImageButton) findViewById(R.id.homeButton);
		ImageButton offerpageButton = (ImageButton) findViewById(R.id.offerpageButton);

		offerpageButton.setOnClickListener(new OnClickListener() {

			public void onClick(View v) {
				// TODO Auto-generated method stub
				Intent offers = new Intent(PersonalEMActivity.this,
						OffersActivity.class);
				startActivity(offers);
			}
		});

	}

	private void getFriendsfromDiaspora() {
		// TODO Auto-generated method stub

		this.contact_names.add(this.getString(R.string.groupFriends)); // add
																		// VENNER
																		// as
																		// first
																		// element
																		// always
		HttpClient friendsClient = getClient();
		String actor = this.user;

		String params = "?user=" + this.user + diaspora;
		HttpGet get = new HttpGet(this.uri + "activities/" + this.activity
				+ "/contacts.json" + params);

	
		Log.d(TAG, "request line: " + get.getParams() + " and uri: "
				+ get.getURI().toASCIIString());
        StringBuilder builder = new StringBuilder();

		try {
            HttpResponse response = friendsClient.execute(get);
            StatusLine statusLine = response.getStatusLine();
            int statusCode = statusLine.getStatusCode();
            if (statusCode == 200) {
                HttpEntity entity = response.getEntity();
                InputStream content = entity.getContent();
                BufferedReader reader = new BufferedReader(new InputStreamReader(content));
                String line;
                while ((line = reader.readLine()) != null) {
                    builder.append(line);
                }
            } else {
                Log.e(TAG, "Failed to download JSON statuscode: " + statusCode);
            }
        } catch (ClientProtocolException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        Log.d(TAG,builder.toString());
    

	}

	private void getUserfromPref() {
		// TODO Auto-generated method stub
		// do something with user.
		SharedPreferences preferences = getSharedPreferences(CONFIG_USER, 0);
		if (!preferences.contains("user")) {
			Log.d(TAG, "creating activity SetUser");
			// if not, then start the "Settings" activity
			startActivity(new Intent(this, SetUserActivity.class));
			this.user = preferences.getString("user", "communityawvej");
			return;
		} else {
			this.user = preferences.getString("user", "communityawvej");
			return;

		}
	}

	@Override
	protected void onNewIntent(Intent intent) {
		super.onNewIntent(intent);
		Log.i(TAG, "received a new intent, do something " + intent.getAction());

		if (intent.getAction().equals("android.nfc.action.NDEF_DISCOVERED")) {
			Log.d(TAG, "TAG_DISCOVERED Receiver catched it");

			String s = NFCIntentParser.parse(intent);
			Log.d(TAG, "NFC string parsed ONNEWINTENT " + s);

		}

		if (intent.getAction().equals(ADKService.SENSOR_EVENT)) {
			Log.d(TAG, "Senso rEvent catched on new intent");
			activityNotification.setText("Here we have a sensor intent!!");
			handleSensorEvent(intent);
		}
	}

	@Override
	public void onDestroy() {
		// TODO Auto-generated method stub
		unregisterReceiver(br);

		super.onDestroy();

	}

	public void onConfigurationChanged(Configuration newConfig) {
		super.onConfigurationChanged(newConfig);
		setContentView(R.layout.main);
		initializeUI();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
	 */
	@Override
	protected void onSaveInstanceState(Bundle outState) {
		// TODO Auto-generated method stub
		super.onSaveInstanceState(outState);
		initializeUI();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// TODO Auto-generated method stub
		MenuInflater inflater = getMenuInflater();
		inflater.inflate(R.menu.menu, menu);
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		// TODO Auto-generated method stub

		switch (item.getItemId()) {
		case R.id.userMenu:
			// call new activity set user name
			startActivity(new Intent(this, SetUserActivity.class));
			return true;
		default:
			return super.onOptionsItemSelected(item);

		}
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		// TODO Auto-generated method stub
		super.onActivityResult(requestCode, resultCode, data);
	}

}